* Setup

Configuring Emacs packages with =use-package= makes it so much simpler. Let's start with 
that.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (progn
      (package-refresh-contents)
      (package-install 'use-package)))
  (require 'use-package)
#+END_SRC

*** Try

I play with a bunch of packages without integrating them into my configuration. Using 
=try= to make throwing them away is wonderful.

#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC

* Look and feel

Next, we'll setup Emacs' look and feel. Start by removing unnecessary visual elements.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
  (setq inhibit-startup-message t)
  (setq inhibit-splash-screen t)
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode 0)
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq backup-directory-alist '(("." . "~/tmp")))
#+END_SRC

Configure =ample= theme, fonts, and scrolling.

#+BEGIN_SRC emacs-lisp
  (use-package ample-theme
    :ensure t
    :init (load-theme 'ample t)
    :config 
    (set-face-attribute 'default nil :height 96)
    (set-face-attribute 'vertical-border nil :foreground (face-attribute 'fringe :background))
    (add-to-list 'default-frame-alist '(height . 40))
    (add-to-list 'default-frame-alist '(width . 90))
    (add-to-list 'default-frame-alist '(font . "Andale-Mono-12"))
    (set-face-attribute 'default t :font "Andale-Mono-12")
    (setq scroll-step 1)
    (setq scroll-conservatively 10000))
#+END_SRC

*** Fringe

Show a 1 pixel fringe.

#+BEGIN_SRC emacs-lisp
  (fringe-mode 1)
  (set-face-attribute 'fringe nil :background "#2d2d2d")
#+END_SRC

Line numbers are useful for pairing, but I like them off by default. Here's 
a keychord to toggle them on/off.

#+BEGIN_SRC emacs-lisp
  (key-chord-define-global "l;" 'linum-mode)
#+END_SRC

*** Terminal

My =ansi-term= buffers should die on terminal exit.

#+BEGIN_SRC emacs-lisp
  (require 'term)
  (defadvice term-handle-exit
      (after term-kill-buffer-on-exit activate)
    (let ((term-name (buffer-name)))
      (progn
        (bury-buffer)
        (kill-buffer term-name))))
#+END_SRC

*** Scratch mode

We'll start Emacs into a =sh-mode= scratch buffer, but remove the buffer 
message since I change its mode often enough for it to be confusing.

#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'sh-mode)
  (setq initial-scratch-message nil)
#+END_SRC

*** Me

Because some Emacs packages might want to know who I am:

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Johnson Denen"
        user-mail-address "johnson.denen@gmail.com")
#+END_SRC

I have work-and-personally-specific functions defined in a non-public file, so 
load that too.

#+BEGIN_SRC emacs-lisp
  (load "~/vc-docs/defs.el")
#+END_SRC

*** OSX

This is a fix for =ansi-term= issues on OSX. Without this, term modes don't have 
access to the =PATH= environment variable.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :init 
    (when (memq window-system '(mac ns))
      (exec-path-from-shell-initialize)))
#+END_SRC

* Org

I use =org-mode= for anything and everything I can, including this config file. I added 
=org-bullets= for a better looking =org-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :init (add-hook 'org-mode-hook 'org-bullets-mode)
    :config 
    (setq org-startup-indented t)
    (setq org-src-fontify-natively t))
#+END_SRC

*** Capture

Notes, todos, code snippets, etc. are gathered with =org-capture=. I use one =org= file, 
a =datetree= structure, and a few templates to annotate my life.

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("n" "Note" entry (file+datetree "~/vc-docs/scratch.org")
           (file "~/.emacs.d/templates/note.orgcaptmpl"))
          ("c" "Code" entry (file+datetree "~/vc-docs/scratch.org")
           (file "~/.emacs.d/templates/code.orgcaptmpl"))
          ("a" "Appt" entry (file+datetree "~/vc-docs/scratch.org")
           (file "~/.emacs.d/templates/appt.orgcaptmpl"))
          ("r" "Refactor" entry (file+datetree "~/vc-docs/scratch.org")
           (file "~/.emacs.d/templates/refactor.orgcaptmpl"))
          ("t" "Task" entry (file+datetree "~/vc-docs/scratch.org")
           (file "~/.emacs.d/templates/task.orgcaptmpl"))))
#+END_SRC

***** Babel

I want captured code to have proper syntax highlighting, indentation, and 
commenting.

#+BEGIN_SRC emacs-lisp
    (setq org-src-tab-acts-natively t)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((ruby . t)
       (sh . t)
       (emacs-lisp . t)
       (clojure . t)
       (js . t)
       (lisp . t)
       (perl . t)
       (python . t)
       (scala . t)
       (sql . t)))
#+END_SRC

***** Bindings

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c c" 'org-capture)
#+END_SRC

*** Agenda

My notes and tasks are no good to me without an easy way to process them. I use 
=org-agenda= to do that.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-start-with-log-mode t
        org-agenda-use-time-grid       t
        org-agenda-include-all-todo    t
        org-agenda-include-diary       t)
#+END_SRC

Completed tasks should be logged with their completion time.

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

***** Pinup

I want to constantly display the agenda buffer in a dedicated window, but I 
wanted to be able to minimize, restore, and jump to that window easily. 

I wrote a minor-mode (=pinup=) to fullfill my need. Here, I add my development  
repository to the load path and toggle the minor mode.

#+BEGIN_SRC emacs-lisp
  (use-package pinup
    :load-path "~/Code/me/pinup"
    :init 
    (require 'pinup)
    :config
    (pinup-mode t)
    (setq pinup-pinned-default-width     80
          pinup-default-pinned-buffer    'org-agenda-list
          pinup-minimize-on-other-window t))
#+END_SRC

***** Diary

I keep a diary file to track recurring appointments, birthdays, etc.

#+BEGIN_SRC emacs-lisp
(setq diary-file "~/vc-docs/diary")
#+END_SRC

***** Bindings

If I have a pinned window, I don't want to delete it with a careless =C-x 1=, 
so I bind the keystroke to =pinup-delete-other-windows=.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c a" 'org-agenda-list)
  (bind-key "C-x 1" 'pinup-delete-other-windows)
#+END_SRC

* Reading

I try to do all my internet reading via Emacs with these packages.

*** Elfeed

I use =org-mode= to configure my RSS reader with =elfeed-org=.

#+BEGIN_SRC emacs-lisp
  (use-package elfeed-org
    :ensure t
    :init 
    (elfeed-org)
    :config
    (setq rmh-elfeed-org-files (list "~/vc-docs/feeds.org")))
#+END_SRC

*** hackernews

#+BEGIN_SRC emacs-lisp
  (use-package hackernews
    :ensure t)
#+END_SRC

* Tramp

Ops work requires a lot of SSH. I use =tramp= to open remote files.

#+BEGIN_SRC emacs-lisp
  (setq tramp-default-method "ssh")
#+END_SRC

Because tramp makes life so easy, I open a ton of remote files and shell 
buffers. I want to destroy them just as easily.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c k" 'tramp-cleanup-all-buffers)
#+END_SRC

*** Shell

Instead of opening =ansi-term= and issuing an =ssh= command, I use this function 
to open =shell= to a remote host. I keep server specific information in a private 
file.

#+BEGIN_SRC emacs-lisp
  (defun my/remote-shell (user host)
    "SSH into remote HOST shell as USER"
    (let ((default-directory (concat "/ssh:" user "@" host ":/")))
      (shell (concat "*" host "*"))))
#+END_SRC

*** SCP

Often, I need to copy a remote file I'm currently working on via =tramp= to another 
server (or back to my local machine). With these functions, I can also copy-and-rename 
or choose other files to copy.

#+BEGIN_SRC emacs-lisp
  (defun cp-current-file ()
    "Move current buffer file."
    (interactive)
    (copy-file (buffer-file-name)
               (call-interactively 'cp--dir)))

  (defun cp-current-file-and-rename ()
    "Move current buffer file and rename it."
    (interactive)
    (copy-file (buffer-file-name)
               (call-interactively 'cp--file)))

  (defun cp-other-file ()
    "Move a file."
    (interactive)
    (copy-file (call-interactively 'cp--file)
               (call-interactively 'cp--dir)))

  (defun cp-other-file-and-rename ()
    "Move a file and rename it."
    (interactive)
    (copy-file (call-interactively 'cp--file)
               (call-interactively 'cp--file)))

  (defun cp-current-directory ()
    "Move current directory."
    (interactive)
    (copy-directory default-directory (call-interactively 'cp--dir) t t))

  (defun cp--file (file)
    "Prompt for FILE and return its filepath."
    (interactive
     (list
      (read-file-name "File: ")))
    (expand-file-name file))

  (defun cp--dir (dir)
    "Prompt for TARGDIR and return its absolute path."
    (interactive
     (list
      (read-directory-name "Target dir: ")))
    (expand-file-name dir))
#+END_SRC

* Hydra

I group logical actions together with =hydra=. This reduces keystrokes to complete my 
common workflows.

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t)
#+END_SRC

* Keychords

I mostly re-use the same functions. Mapping these to keystrokes with =key-chord= makes my 
life easier.

#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :ensure t
    :init (key-chord-mode 1))
#+END_SRC

* Registers

I'm in the same few files much more than others. Mostly, I'm tweaking bash and Emacs 
configuration or jumping to my =org-agenda= file. To access them quickly, I add them 
to a register.

#+BEGIN_SRC emacs-lisp
  (mapcar
   (lambda (r)
     (set-register (car r) (cons 'file (cdr r))))
   '((?i . "~/.emacs.d/config.org")
     (?b . "~/.bashrc")
     (?s . "~/vc-docs/scratch.org")
     (?j . "~/vc-docs/johnson.org")))
#+END_SRC

*** Bindings

#+BEGIN_SRC emacs-lisp
  (key-chord-define-global "jr" 'jump-to-register)
#+END_SRC

* Magit

If my life is annotated with =org-capture=, formatted in =org-mode=, and managed with 
=org-agenda=, then its history is stored in Git. And no piece of software does Git better 
than =magit=.

#+BEGIN_SRC emacs-lisp
    (use-package magit
      :ensure t
      :init (setq magit-push-always-verify nil)
      :config (key-chord-define-global "MM" 'magit-status))
#+END_SRC

*** Gutters

I like to see my changes in the buffer's gutter. I use =diff-hl= to show those changes.

# #+BEGIN_SRC emacs-lisp
#   (use-package git-gutter
#     :ensure t
#     :diminish git-gutter-mode
#     :init (progn
#             (global-git-gutter-mode +1)
#             (fringe-mode '(4 . 4)))
#     :config 
#     (setq git-gutter:linum-enabled t)
#     (key-chord-define-global "GG" 'my/gutter))
# #+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :ensure t
    :init
    (diff-hl-mode)
    :config
    (global-diff-hl-mode t))
#+END_SRC

***** Hydra
#+BEGIN_SRC emacs-lisp
  (defun my/gutter ()
    "Open git-gutter hydra"
    (interactive)
    (hydra/gutter/body))

  (defhydra hydra/gutter ()
    "Git"
    ("n" git-gutter:next-hunk "Next")
    ("p" git-gutter:previous-hunk "Prev")
    ("s" git-gutter:stage-hunk "Stage")
    ("r" git-gutter:revert-hunk "Revert")
    ("u" git-gutter:update-all-windows "Update")
    ("q" keyboard-quit "Quit" :exit t))
#+END_SRC

* Projectile

Git projects are a snap to navigate and manage with =projectile=. Its default keybindings 
work for me too.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init (projectile-global-mode t))
#+END_SRC

* Helm

Navigating buffers and windows with =helm= is slick. I use =helm-M-x= to navigate functions 
and =helm-mini= for buffers and files.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :diminish helm-mode
    :init (progn
            (helm-mode 1)
            (require 'helm-config))
    :config 
    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z") 'helm-select-action)
    (setq helm-quick-update                     t
          helm-buffers-fuzzy-matching           t
          helm-move-to-line-cycle-in-source     t
          helm-ff-search-library-in-sexp        t
          helm-scroll-amount                    8
          helm-ff-file-name-history-use-recentf t)
    (key-chord-define-global "yy" 'helm-show-kill-ring)
    :bind
    ("C-x m" . helm-M-x)
    ("C-c m" . helm-mini)
    ("C-x b" . helm-mini)
    ("C-x 4 b" . helm-mini))
#+END_SRC

*** Swoop

Searches with =helm-swoop= make multiline editing easier. I default to 
=helm-swoop-without-pre-input= becuase I often swoop after opening a file.

The =helm-multi-swoop-org= function works perfectly when I want to find a captured 
note or task from a non-org buffer.

#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :ensure t
    :bind
    ("C-s" . helm-swoop-without-pre-input)
    ("C-r" . helm-swoop)
    ("C-M-s" . helm-multi-swoop-org))
#+END_SRC

*** Ag

I use =helm-projectile-ag= for searching files in a Git project and =helm-ag= for 
searches outside of version control.

#+BEGIN_SRC emacs-lisp
  (use-package helm-ag
    :ensure t)
#+END_SRC

*** Projectile

I love =projectile= and I love =helm=, so using them together makes sense.

#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :ensure t
    :init (helm-projectile-on))
#+END_SRC

* Buffer management

I use =ace-jump-mode= mostly for jumping to the beginning of words. But jumping to a char is 
necessary when a word is interpreted unintuitively. And popping back to where I came from 
makes buffer navigation easy, so I bind all three of these functions to keychords.

#+BEGIN_SRC emacs-lisp
  (use-package ace-jump-mode
    :ensure t
    :config 
    (key-chord-define-global "jj" 'ace-jump-char-mode)
    (key-chord-define-global "jw" 'ace-jump-word-mode)
    (key-chord-define-global "jb" 'ace-jump-mode-pop-mark))
#+END_SRC

***** Bindings

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x k" 'bury-buffer)
  (bind-key "C-x C-k" 'kill-this-buffer)
#+END_SRC

* Window management

Despite its similiar name, =ace-window= is more a window management package than the navigation 
package that =ace-jump-mode= is. As long as =aw-dispatch-always= is set to =t=, I can kill, 
maximize, swap, and switch to windows with =C-x o=.

#+BEGIN_SRC emacs-lisp
  ;; Dispatch actions:
  ;;   x Delete window
  ;;   m Swap window
  ;;   n Previous window
  ;;   v Split vertically
  ;;   b Split horizontally
  ;;   o Delete others
  ;;   i Maximize window
  (use-package ace-window
    :ensure t
    :init (setq aw-dispatch-always t)
    :bind ("C-x o" . ace-window))
#+END_SRC

***** Bindings

#+BEGIN_SRC emacs-lisp
  (bind-key "C-+" 'text-scale-increase)
  (bind-key "C--" 'text-scale-decrease)
  (bind-key "C-<" 'shrink-window-horizontally)
  (bind-key "C->" 'enlarge-window-horizontally)
  (bind-key "C-," 'shrink-window)
  (bind-key "C-." 'enlarge-window)
#+END_SRC

* Region management

I capture regions with =expand-region=. But I never expand to a region without purpose, so 
I attach my expansion to a =hydra=. This makes it so much more useful.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :config 
    (defun my/expand-region ()
      "Expand region into hydra."
      (interactive)
      (progn
        (er/expand-region 1)
        (hydra/expand/body)))
    (key-chord-define-global ";;" 'my/expand-region))
#+END_SRC

***** Bindings

#+BEGIN_SRC emacs-lisp
  (bind-key "s-b" 'backward-sexp)
  (bind-key "s-f" 'forward-sexp)
#+END_SRC

*** Hydra

#+BEGIN_SRC emacs-lisp
  (defhydra hydra/expand ()
    "Expand"
    ("x" er/expand-region "Expand")
    ("c" er/contract-region "Contract")
    ("w" kill-region "Kill")
    ("y" yank "Yank")
    ("m" helm-M-x "Command")
    ("q" keyboard-quit "Quit" :exit t))
#+END_SRC

* Mistake management

When you write a lot of code, you make a lot of typos. I use =undo-tree= to manage them. 

I use a =hydra= to string undo commands without re-entering the keystroke.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :init (global-undo-tree-mode 1)
    :config 
    (defun my/undo ()
      "Undo last edit into hydra."
      (interactive)
      (progn
        (undo-tree-undo)
        (hydra/undo/body)))
    (key-chord-define-global "uu" 'my/undo))
#+END_SRC

*** Hyrda

#+BEGIN_SRC emacs-lisp
  (defhydra hydra/undo ()
    "Undo"
    ("u" undo-tree-undo "Undo")
    ("r" undo-tree-redo "Redo")
    ("q" keyboard-quit "Quit" :exit t))
#+END_SRC

* Smart parentheses

Using Emacs, I write a decent amount of lisp. Having =smartparents= for that alone is worth 
the install, but its Ruby mode is great too.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :diminish smartparens-mode
    :init (progn
            (require 'smartparens-config)
            (require 'smartparens-ruby)
            (smartparens-global-mode 1)
            (show-smartparens-global-mode 1)))
#+END_SRC

* Smart commenting

I always hated that =M-;= added a comment to the end of the line, no matter the position from 
which you called it. Fixed with =smart-comment=, which provides sane commenting configuration.

#+BEGIN_SRC emacs-lisp
  (use-package smart-comment
    :ensure t
    :bind ("M-;" . smart-comment))
#+END_SRC

* JSON, YAML, Markdown

While I prefer all my text to be of the =org= persuasion, it's hard to avoid working with 
these three formats in my day-to-day. I just add their major-mode packages with little 
configuration.

#+BEGIN_SRC emacs-lisp
  (use-package json-reformat
    :ensure t
    :init (setq json-reformat:indent-width 2))

  (use-package markdown-mode
    :ensure t)

  (use-package yaml-mode
    :ensure t)
#+END_SRC

* Acceptance critera

I try to avoid Cucumber at all costs, but I do believe in acceptance critera. That usually 
means Gherkin, so I install =feature-mode= for syntax highlighting.

#+BEGIN_SRC emacs-lisp
  (use-package feature-mode
    :ensure t)
#+END_SRC

* Docker

I interact with a number of docker containers and Dockerfiles.

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :ensure t)
#+END_SRC

* Emacs Lisp

I enjoy writing Lisp code, and I want to do more of it.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-package
    :ensure t)
#+END_SRC

* Ruby

The =robe= package adds pretty decent code navigation and documentation for Ruby. I ensure 
it loads with a =ruby-mode-hook=.

#+BEGIN_SRC emacs-lisp
  (use-package yard-mode
    :ensure t
    :diminish yard-mode
    :init (add-hook 'ruby-mode-hook 'yard-mode))
#+END_SRC

***** Autocomplete

The =robe= package provides autocompletion, but I think =auto-complete= makes it 
feature complete.

#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :ensure t
    :init (progn
            (ac-config-default)
            (add-hook 'robe-mode-hook 'ac-robe-setup)))
#+END_SRC

*** RSpec

I test drive all my Ruby code, and =rspec-mode= adds a bunch of useful functions for that.

#+BEGIN_SRC emacs-lisp
  (use-package rspec-mode
    :ensure t
    :diminish rspec-mode
    :init (progn
            (setq rspec-use-rake-when-possible nil)
            (setq rspec-command-options "--format progress"))
    :bind ("C-c , T" . rspec-find-spec-or-target-other-window))
#+END_SRC

*** Rubocop

I try to adhere to Ruby community standards. Rubocop helps.

#+BEGIN_SRC emacs-lisp
  (use-package rubocop
    :ensure t)
#+END_SRC

* Groovy

I work with Jenkins, which means I work with Groovy. I add =groovy-mode= without 
configuration for this.

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :ensure t)
#+END_SRC

*** Gradle

Running tasks with =gradle-mode= makes my work in Groovy scripting easier.

#+BEGIN_SRC emacs-lisp
  (use-package gradle-mode
    :ensure t
    :init (add-hook 'groovy-mode-hook 'gradle-mode))
#+END_SRC

*** Tabs

For whatever reason, I have issues with tabs over spaces in =groovy-mode=. I add a hook 
here to remove this problem.

#+BEGIN_SRC emacs-lisp
  (defun my/tab-hook ()
    (setq indent-tabs-mode nil))

  (add-hook 'groovy-mode-hook 'my/tab-hook)
#+END_SRC

* Twitter

I like twitter. I like Emacs. I like tweeting from Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package twittering-mode
    :ensure t
    :init (progn
            (setq twittering-icon-mode t)
            (setq twittering-use-master-password t)))
#+END_SRC

* Disconnect

As much as I like twitter, sometimes I need to disconnect and focus. I added =quiet= to 
cut me off from the world (wide web) when needed.

#+BEGIN_SRC emacs-lisp
  (use-package quiet
    :ensure t
    :init (setq quiet-timer 30))
#+END_SRC

* HTTP

I use the =know-your-http-well= package to quickly look up the meaning of status codes.

#+BEGIN_SRC emacs-lisp
  (use-package know-your-http-well
    :ensure t)
#+END_SRC
